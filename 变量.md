# 变量
## let
let所声明的变量，只在let命令所在的代码块内有效。
for循环中，定义的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量。
另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。
```
for (let i = 0; i < 3; i++) {
  let i = 'abc';
  console.log(i);
}
// abc
// abc
// abc
```

上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。

- 不存在变量提升 

 **不是undifine而是ReferenceError**
 
 只要一进入当前作用域，只有等到声明变量的那一行代码出现，才可以获取和使用该变量，父级作用域声明的同名变量无效。
 
- 不允许重复声明 

不允许在相同作用域内，重复声明

## 作用域
ES6 有全局作用域和函数作用域，
增加块级作用域,
明确允许在块级作用域之中声明函数，在块级作用域之外不可引用。

块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。

改变了块级作用域内声明的函数的处理规则,也会对老代码产生很大影响。
为了减轻因此产生的不兼容问题，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

- 允许在块级作用域内声明函数。
- 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

### do
块级作用域没有返回值,do 表达式返回内部最后执行的表达式的值。

## const
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。
如果真的想将对象冻结，应该使用Object.freeze方法。

只冻结对象，不冻结对象的属性。
```javaScript
"use strict"
const foo = Object.freeze({prop: {
    bar: 'bar'
    }});

foo.prop.bar = 123;//不会报错

console.log(foo)
```

##  6种声明变量的方法
let 
const
class 
import
function
var

## 顶层对象的属性
顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。

ES5 之中，顶层对象的属性与全局变量是等价的。

ES6 :
- 为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；
- let、const、class声明的全局变量，不属于顶层对象的属性。

也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

### global 对象不统一
- 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。
- 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。
- Node 里面，顶层对象是global，但其他环境都不支持。

## 疑问
如何保证各种环境里面，global对象都是存在的。

立即执行的函数表达式
- 不必为函数命名，避免了污染全局变量
- IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。

## 项目
块级作用域替换IIFE