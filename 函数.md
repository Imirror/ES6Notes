# 函数
## 箭头函数
箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。
由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。

很方便地改写 **λ 演算**。

##  尾调用优化

只保留内层函数的调用帧。

## 尾递归
递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

尾递归优化过的 Fibonacci 数列实现如下。
```
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

``` 
尾调用模式仅在严格模式下生效。
这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。

- `func.arguments`：返回调用时函数的参数。
- `func.caller`：返回调用当前函数的那个函数。

参数变多： 参数默认值，柯里化



## ？？

- λ 演算
- 柯里化

尾调用优化实现
- 一直bind 为什么不会栈溢出
- 真正的实现